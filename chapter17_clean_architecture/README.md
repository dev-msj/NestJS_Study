SOLID 원칙을 준수하여 클린 아키텍쳐를 구성해보자.

### SRP(Single Responsibility Principle, 단일 책임 원칙)

> 한 클래스는 하나의 책임만 가져아 한다.

즉, 클래스를 변경하는 이유는 오직 한 가지뿐이어야 한다는 말이다.<br>
예를 들어, 유저 서비스 클래스에서 DB 서비스나 email 서비스를 처리하는 로직이 존재한다면<br>
이는 3가지의 책임을 가지고 있으므로 SRP를 위배한다.

### OCP(Open Close Principle, 개방 폐쇄 원칙)

> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

즉, 기능의 추가가 기존의 코드에 영향을 끼치지 않는 구조를 말한다.<br>
이 원칙은 인터페이스를 활용하여 쉽게 달성할 수 있다.<br>
구현체에 의존하지 말고 인터페이스에 의존하도록 하면 된다.<br>
이를 통해 추가로 필요한 기능이 있을 때, 인터페이스만 추가하여<br>
기존 코드에 영향없이 확장이 가능하게 된다.<br>

### LSP(Liskov Substitution Principle, 리스코프 치환 원칙)

> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

실제 구현체인 자식 인스턴스는 언제든지 부모 또는 인터페이스의<br>
기능을 제공하는 다른 구현체로 바꿀 수 있다.

### ISP(Interface Segregation Principle, 인터페이스 분리 원칙)

> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

인터페이스를 기능별로 잘게 쪼개어 특정 클라이언트용 인터페이스로 모아 사용하는 것을 말한다.ㅊ
결과적으로 변경에 대한 의존성을 낮추고 유연하게 대철할 수 있게 된다.

### DIP(Dependency Inversion Principle, 의존관계 역전 원칙)

> 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.

자주 변화하는 구체적인 것이 아닌, 변하지 않는 추상적인 개념에 의존하여야 한다는 것이다.<br>
예를 들어, 사람이 있고 기타와 베이스를 연주할 수 있다고 하자.<br>
이 때 "사람이 기타를 연주한다", "사람이 베이스를 연주한다"를 각각 구현하는 것은 비효율적이다.<br>
만약 바이올린이나 통기타가 추가된다고 하면 이것들도 매번 구현해야 한다.<br>